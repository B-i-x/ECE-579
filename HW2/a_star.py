# -*- coding: utf-8 -*-
"""a_star.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pLyJ8BESw4Ggx13oEGVaIszdclqdEfrk

# Using A* algorithm for maze solving

## Generating the maze problem
We start by generating a random maze problem. \
We define the map has a size (height = m, width = n) \
"""

import numpy as np
m = 41
n = 41
maze = np.full((m, n), '0')
print(maze)

"""We randomly add '1's onto the table. '1' means obstacle, and '0' means passable.
* we first define the even lines are all '0's
* we then make the odd lines are 101010...
"""

for i in range(m):
  if i % 2 == 0:
    maze[i] = np.full(n, '0') # the even lines are all zero
  else:
    for j in range(n):
      if j % 2 == 0:  # the odd lines are 010101...
        maze[i][j] = '1'
      else:
        maze[i][j] = '0'

print(maze)

"""In order to print our map clearly, we can use ðŸŸ¦ to represent all '0's, we use ðŸŸ¨ to represent all '1's, and we will use ðŸŸ© to represent the path in the future.

Note: we make a copy of the maze here in the line "maze_copy = maze.copy()", so we don't change the original maze directly.
"""

def print_maze(maze):

  # create a copy of the maze
  maze_copy = maze.copy()

  for i in range(len(maze_copy)):
    for j in range(len(maze_copy[0])):
      if maze_copy[i][j] == '0':
        maze_copy[i][j] = 'ðŸŸ¦'
      elif maze_copy[i][j] == '1':
        maze_copy[i][j] = 'ðŸŸ¨'
      elif maze_copy[i][j] == '2':
        maze_copy[i][j] = 'ðŸŸ©'

  print('\n'.join(''.join(row) for row in maze_copy)) ## we print the maze line by line

print_maze(maze)

"""We try to make the maze problem not trivial. For example, for the even lines, 0, 2, 4,..., we randomly select 10 tiles to make them '1'."""

import random

for i in range(m):
  if i % 2 ==0 and i < m-4 and i > 0:
    x = random.sample(range(0, n), 10)
    for j in range(10):
      maze[i][x[j]] = '1'

print_maze(maze)

"""## A* algorithm

**Step 1:**\
Define the **get_neighbors** function to facilitate our search. For each tile, considers 4 surrounding positions, up, left, right, down and left. Count one of them as a 'neighbor' if it is not beyond the board and it is not '1'.
"""

def get_neighbors(maze, i, j):
    neighbors = []
    """In order to consider the diagonal neighbors, we add 4 more directions of (-1,-1), (-1, 1), (1, -1), (1, 1)"""
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1,-1), (-1, 1), (1, -1), (1, 1)]

    for di, dj in directions:
        ni, nj = i + di, j + dj
        if 0 <= ni < len(maze) and 0 <= nj < len(maze[0]) and maze[ni][nj] == '0':
            neighbors.append((ni, nj))
    return neighbors

"""Define another function to print the top-left corner of the maze. Use the 'red' color to represent the considered point."""

def print_maze2(maze, explore_point):

  # create a copy of the maze
  maze_copy = maze.copy()

  for i in range(len(maze_copy)):
    for j in range(len(maze_copy[0])):
      if maze_copy[i][j] == '0':
        maze_copy[i][j] = 'ðŸŸ¦'
      elif maze_copy[i][j] == '1':
        maze_copy[i][j] = 'ðŸŸ¨'
  maze_copy[explore_point[0]][explore_point[1]] = 'ðŸŸ¥'
  print('\n'.join(''.join(row) for row in maze_copy)) ## we print the maze line by line


print('the neighbors of (0,0) are ', get_neighbors(maze, 0, 0))
print_maze2(maze[0:5, 0:5], (0,0))

print('the neighbors of (0,1) are ', get_neighbors(maze, 0, 1))
print_maze2(maze[0:5, 0:5], (0,1))

print('the neighbors of (0,2) are ', get_neighbors(maze, 0, 2))
print_maze2(maze[0:5, 0:5], (0,2))

# """**Step 2:**\
# define the **manhattan_distance** function.
# """

# def manhattan_distance(a, b):
#     return abs(a[0] - b[0]) + abs(a[1] - b[1])

"""**Step 2:**
define the **euclidean_distance** function.
"""
import math
def euclidean_distance(a, b):
    return math.sqrt(abs(a[0] - b[0]) ** 2 + abs(a[1] - b[1]) ** 2)

"""**Step 3:**\
assign the start point to be (0,0), the goal point is (m-1, 0)
"""

## define the start point and goal point
start = (0,0)
goal = (m-1, 0)

"""**Step 4:**\
We implement the A* algorithm by first defining necessary lists (and dictionaries).

Note: The dictionary is one type of data structure in python that helps fast refer / extract the attribute of objects. For example:
"""

# Example of a Python dictionary
class_1 = {
    "id1": "Alice",
    "id2": 'John',
    "id3": "Peter"
}

print(class_1["id1"])
print(class_1["id3"])

"""We define f_score as dictionaries for retriveing the f score of each position."""

open_list = [start] # a list of points that we need to compare.
came_from = {}  # to record where a point came from, i.e, its previous point.
g_score = {start: 0}  # dictionary, (0,0): 0, (0,1):1
f_score = {start: euclidean_distance(start, goal)}  # dictionary, (0,0): 0, (0,1):1
visited = [] # a list of visited points

step = 0
path = []

while open_list:
  step = step + 1
  current = min(open_list, key=lambda x: f_score.get(x, float('inf')))  # find the points with minimal f score
  open_list.remove(current) # we remove the current point from open_list because we don't need to further consider it

  if current == goal:
    while current in came_from:
        path.append(current)
        current = came_from[current]
    path.append(start)
    path.reverse()
    break # stop the algorithm

  visited.append(current)  # record the current point is visited

  if step < 5:
    print('########################')
    print('step ', step)
    print('we now explore: ' , current, ', which is the one with minimal f score from the previous openlist')
    print('it has neighbors: ', get_neighbors(maze, current[0], current[1]))

    if current[0] < 5 and current[1] < 5:
      print_maze2(maze[0:5, 0:5], current)

  for neighbor in get_neighbors(maze, current[0], current[1]):
    if neighbor in visited:
      if step < 5:
        print('for the neighbor ', neighbor, ', it has been visited')
      continue

    tentative_g_score = g_score[current] + 1

    if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
        came_from[neighbor] = current # record where this neighor came from, for retriving final path
        g_score[neighbor] = tentative_g_score
        f_score[neighbor] = tentative_g_score + euclidean_distance(neighbor, goal)
        if neighbor not in open_list:
            open_list.append(neighbor)
    if step < 5:
      print('for the neighbor ', neighbor, ', it has g value' , g_score[neighbor], 'and f value' , f_score[neighbor])

  if step < 5:
    print('we should consider to explore the openlist ', open_list)
    print('and they have the f scores: ', {key: f_score[key] for key in f_score if key in open_list})

"""**Results**
print the path on the map
"""

print("Path:", path)

# create a copy of the maze
maze2 = maze.copy()
for i, j in path:
  maze2[i][j] = '2'
print_maze(maze2)

"""**Running Experiment 1**
The length of the path between the start point (0, 0) and the goal point
(m - 1, n - 1), where m, n are the height & width of the map, and (m -
1, n - 1) is the bottom right corner of the map
"""
"""first we make a function to create the maze"""

def create_maze(m, n):
  maze = np.full((m, n), '0')
  for i in range(m):
    if i % 2 == 0:
      maze[i] = np.full(n, '0') # the even lines are all zero
    else:
      for j in range(n):
        if j % 2 == 0:  # the odd lines are 010101...
          maze[i][j] = '1'
        else:
          maze[i][j] = '0'
          
  for i in range(m):
        if i % 2 ==0 and i < m-4 and i > 0:
            x = random.sample(range(0, n), 10)
            for j in range(10):
                maze[i][x[j]] = '1'
  return maze

"""second we define a function to run the whole simulation the path length"""

def run_simulation(maze, m, n):
  ## define the start point and goal point
  start = (0,0)
  goal = (m, n)

  # Example of a Python dictionary
  open_list = [start] # a list of points that we need to compare.
  came_from = {}  # to record where a point came from, i.e, its previous point.
  g_score = {start: 0}  # dictionary, (0,0): 0, (0,1):1
  f_score = {start: euclidean_distance(start, goal)}  # dictionary, (0,0): 0, (0,1):1
  visited = [] # a list of visited points

  step = 0
  path = []

  while open_list:
      step = step + 1
      current = min(open_list, key=lambda x: f_score.get(x, float('inf')))  # find the points with minimal f score
      open_list.remove(current) # we remove the current point from open_list because we don't need to further consider it

      if current == goal:
          while current in came_from:
              path.append(current)
              current = came_from[current]
          path.append(start)
          path.reverse()
          break # stop the algorithm

      visited.append(current)  # record the current point is visited
      for neighbor in get_neighbors(maze, current[0], current[1]):
          tentative_g_score = g_score[current] + 1

          if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
              came_from[neighbor] = current # record where this neighor came from, for retriving final path
              g_score[neighbor] = tentative_g_score
              f_score[neighbor] = tentative_g_score + euclidean_distance(neighbor, goal)
              if neighbor not in open_list:
                  open_list.append(neighbor)

  return path

"""finally we define a function to run the experiment"""

def run_experiment_1(m, n):
  random.seed(100)

  m = 41
  n = 41
  maze = create_maze(m, n)
  print(f"maze size: {m}x{n}")
  print_maze(maze)

  path = run_simulation(maze, m, n)

  solved_maze = maze.copy()

  for i, j in path:
    solved_maze[i][j] = '2'
  print(f"Solved maze:")

  print_maze(solved_maze)

  print(f"Path length: {len(path)}")

"""**Running Experiment 2**"""

"""with the experiment 1 function, we can easily run the experiment 2 with some quick modifications"""

def run_experiment_2(m, n):
  """
  For each column j in [0..n-1], compute the path length from (0,0) to (m-1, j).
  """
  random.seed(100)  # Ensure reproducible results
  m = 41
  n = 41
  # 1. Create the maze
  maze = create_maze(m, n)
  print(f"maze size: {m}x{n}")
  print_maze(maze)

  # 2. For each goal (m-1, j), find and record the path length
  for j in range(n):
    path = run_simulation(maze, m-1, j)  
    path_length = len(path)
    print(f"Path length to goal (m-1, {j}): {path_length}")

    # solved_maze = maze.copy()
    # for (row_idx, col_idx) in path:
    #     solved_maze[row_idx][col_idx] = '2'
    # print(f"Solved maze for goal (m-1, {j}):")
    # print_maze(solved_maze)


if __name__ == "__main__":
  run_experiment_2(m, n)